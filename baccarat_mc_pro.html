<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>百家樂 PRO（只顯示下注建議＋按鈕輸入）</title>
  <style>
    :root{
      --fg:#111; --muted:#666; --bd:#e6e6e6; --bg:#fff; --soft:#fafafa;
      --banker:#d32f2f; /* 莊紅 */
      --player:#1976d2; /* 閒藍 */
      --tie:#2e7d32;    /* 和綠 */
      --warn:#b00020; --ok:#0b6;
    }
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans TC",sans-serif;
      margin:14px; color:var(--fg); background:var(--bg);
      padding-bottom: 90px;
    }
    .card{border:1px solid var(--bd); border-radius:16px; padding:14px; margin-top:12px; background:#fff;}
    .muted{color:var(--muted);}
    .warn{color:var(--warn);}
    .ok{color:var(--ok);}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    button,input{font:inherit;}
    button{
      border:1px solid var(--bd); background:#fff; color:var(--fg);
      border-radius:14px; padding:12px 12px; cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    button:active{transform: translateY(1px);}
    button.primary{background:#111; border-color:#111; color:#fff;}
    button.danger{border-color:var(--warn); color:var(--warn);}
    .bigRec{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .recText{
      font-weight:800;
      font-size: clamp(28px, 6.5vw, 52px);
      letter-spacing: .02em;
      line-height: 1.05;
    }
    .pill{
      display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid var(--bd);
      background:var(--soft); font-size:12px; color:var(--muted);
      white-space:nowrap;
    }

    .gridRanks{
      display:grid;
      grid-template-columns: repeat(7, minmax(0,1fr));
      gap:10px;
      margin-top:10px;
    }
    @media (max-width:420px){
      .gridRanks{grid-template-columns: repeat(5, minmax(0,1fr));}
    }
    .rankBtn{
      padding:14px 0;
      font-weight:700;
      border-radius:14px;
      background:var(--soft);
    }
    .rankBtn:active{background:#f0f0f0;}
    .bufferBox{
      border:1px dashed var(--bd);
      border-radius:14px;
      padding:12px;
      background:#fff;
      min-height: 44px;
    }
    .tiny{font-size:12px;}
    .progress{height:10px; background:#eee; border-radius:999px; overflow:hidden;}
    .bar{height:100%; width:0%; background:#111;}
    .hide{display:none;}
  </style>
</head>
<body>

  <div class="card">
    <div class="bigRec">
      <div>
        <div class="muted tiny">建議下注</div>
        <div id="rec" class="recText">—</div>
      </div>
      <div class="row" style="justify-content:flex-end;">
        <span id="shoeInfo" class="pill mono">8副牌｜剩餘：—</span>
        <span id="burnInfo" class="pill mono">燒牌：—</span>
      </div>
    </div>

    <div class="row" style="margin-top:12px;">
      <button id="btnCompute" class="primary">計算下一局</button>
      <label class="pill mono">模擬
        <input id="trials" type="number" min="10000" step="10000" value="200000"
               style="width:120px; margin-left:6px; border:0; outline:0; background:transparent;" />
      </label>
      <button id="btnUndo" class="danger">復原1張</button>
      <button id="btnClear" class="danger">清空本輪</button>
      <button id="btnReset" class="danger">重置新牌靴</button>
    </div>

    <div style="margin-top:10px;">
      <div class="muted tiny">本輪已輸入（將會扣牌）</div>
      <div id="buffer" class="bufferBox mono"></div>
    </div>

    <div style="margin-top:10px;">
      <div class="muted tiny">計算進度</div>
      <div class="progress"><div id="bar" class="bar"></div></div>
      <div id="msg" class="muted tiny" style="margin-top:6px;"></div>
    </div>
  </div>

  <div class="card">
    <div class="row" style="justify-content:space-between;">
      <div>
        <div style="font-weight:700;">按鈕輸入牌</div>
        <div class="muted tiny">點一下就加入本輪（花色不分）</div>
      </div>
      <button id="btnToggleDetails">顯示/隱藏細節</button>
    </div>

    <div class="gridRanks" id="rankPad"></div>

    <!-- 細節（預設隱藏，符合你「只顯示下注」需求） -->
    <div id="details" class="hide" style="margin-top:12px;">
      <div class="row">
        <span class="pill mono">P(閒)=<span id="pProb">—</span></span>
        <span class="pill mono">P(莊)=<span id="bProb">—</span></span>
        <span class="pill mono">P(和)=<span id="tProb">—</span></span>
      </div>
      <div class="muted tiny" style="margin-top:8px;">
        這些數字只是參考；主要看上方「建議下注」。
      </div>
    </div>
  </div>

<script>
(() => {
  // =========================
  // 基本設定
  // =========================
  const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const IDX = new Map(RANKS.map((r,i)=>[r,i]));
  const MAX_DRAW = 6;
  const N_DECKS = 8;

  // localStorage
  const SAVE_KEY = "baccarat_min_ui_state_v1";

  // UI
  const elRec = document.getElementById("rec");
  const elTrials = document.getElementById("trials");
  const elBuffer = document.getElementById("buffer");
  const elMsg = document.getElementById("msg");
  const elBar = document.getElementById("bar");
  const elShoeInfo = document.getElementById("shoeInfo");
  const elBurnInfo = document.getElementById("burnInfo");
  const elDetails = document.getElementById("details");
  const elP = document.getElementById("pProb");
  const elB = document.getElementById("bProb");
  const elT = document.getElementById("tProb");

  function setMsg(t, cls="muted"){ elMsg.className = cls + " tiny"; elMsg.textContent = t; }
  function setProgress(frac){ elBar.style.width = `${Math.max(0,Math.min(1,frac))*100}%`; }
  function resetProgress(){ setProgress(0); }

  // =========================
  // 牌靴（counts）
  // =========================
  function newShoeCounts(nDecks=N_DECKS){
    const counts = new Int16Array(RANKS.length);
    for(let i=0;i<counts.length;i++) counts[i] = 4*nDecks;
    return counts;
  }
  function shoeSize(counts){
    let s=0; for(let i=0;i<counts.length;i++) s+=counts[i]; return s;
  }

  // 抽一張（依 counts 權重）
  function drawOneFromCounts(counts){
    const total = shoeSize(counts);
    if(total <= 0) throw new Error("牌靴已空");
    const k = randIntBelow(total);
    let acc=0;
    for(let i=0;i<counts.length;i++){
      acc += counts[i];
      if(k < acc){
        counts[i]--;
        return RANKS[i];
      }
    }
    // 理論不會到這
    counts[counts.length-1]--;
    return RANKS[counts.length-1];
  }

  function removeCardsFromShoe(counts, cards){
    for(const r of cards){
      const i = IDX.get(r);
      if(i == null) throw new Error("不認得的牌："+r);
      if(counts[i] <= 0) throw new Error(`牌靴裡 ${r} 已經沒了，不能再扣。`);
      counts[i]--;
    }
  }

  // =========================
  // 百家樂點數 / 規則
  // =========================
  function rankValue(rank){
    if(rank==="A") return 1;
    if(rank==="10"||rank==="J"||rank==="Q"||rank==="K") return 0;
    return Number(rank);
  }
  function handTotal(cards){
    let s=0; for(const r of cards) s += rankValue(r);
    return s % 10;
  }

  function playOneRoundFromDraw(draw6){
    const p = [draw6[0], draw6[1]];
    const b = [draw6[2], draw6[3]];
    let pt = handTotal(p);
    let bt = handTotal(b);

    // natural
    if(pt===8||pt===9||bt===8||bt===9){
      if(pt>bt) return 0; // Player
      if(bt>pt) return 1; // Banker
      return 2;           // Tie
    }

    let idx = 4;
    let pThird = null;

    if(pt <= 5){
      pThird = draw6[idx++]; p.push(pThird);
      pt = handTotal(p);
    }

    bt = handTotal(b);
    if(pThird === null){
      if(bt <= 5){
        b.push(draw6[idx++]);
        bt = handTotal(b);
      }
    }else{
      const pv = rankValue(pThird);
      if(bt <= 2){
        b.push(draw6[idx++]);
      }else if(bt === 3 && pv !== 8){
        b.push(draw6[idx++]);
      }else if(bt === 4 && (pv>=2 && pv<=7)){
        b.push(draw6[idx++]);
      }else if(bt === 5 && (pv>=4 && pv<=7)){
        b.push(draw6[idx++]);
      }else if(bt === 6 && (pv===6 || pv===7)){
        b.push(draw6[idx++]);
      }
      bt = handTotal(b);
    }

    if(pt>bt) return 0;
    if(bt>pt) return 1;
    return 2;
  }

  // =========================
  // WebCrypto RNG（均勻）
  // =========================
  function randIntBelow(n){
    const max = 0x100000000;
    const limit = max - (max % n);
    const buf = new Uint32Array(1);
    while(true){
      crypto.getRandomValues(buf);
      const x = buf[0];
      if(x < limit) return x % n;
    }
  }

  // =========================
  // 蒙地卡羅（partial shuffle + restore）
  // =========================
  function expandDeckFromCounts(counts){
    const deck = [];
    for(let i=0;i<counts.length;i++){
      for(let k=0;k<counts[i];k++) deck.push(RANKS[i]);
    }
    return deck;
  }
  function draw6FastInPlace(deck, swapsJ){
    const n = deck.length;
    for(let i=0;i<MAX_DRAW;i++){
      const j = i + randIntBelow(n - i);
      swapsJ[i] = j;
      const tmp = deck[i]; deck[i] = deck[j]; deck[j] = tmp;
    }
    return [deck[0],deck[1],deck[2],deck[3],deck[4],deck[5]];
  }
  function restoreDeck(deck, swapsJ){
    for(let i=MAX_DRAW-1;i>=0;i--){
      const j = swapsJ[i];
      const tmp = deck[i]; deck[i] = deck[j]; deck[j] = tmp;
    }
  }

  function estimateProbs(counts, trials, onProgress){
    const m = shoeSize(counts);
    if(m < 6) throw new Error("剩餘牌不足以模擬（至少要 >=6 張）。");

    const deck = expandDeckFromCounts(counts);
    const swapsJ = new Int32Array(MAX_DRAW);

    let pw=0, bw=0, tw=0;
    const step = Math.max(5000, Math.floor(trials / 200));

    for(let k=1;k<=trials;k++){
      const draw6 = draw6FastInPlace(deck, swapsJ);
      const out = playOneRoundFromDraw(draw6);
      if(out===0) pw++;
      else if(out===1) bw++;
      else tw++;

      restoreDeck(deck, swapsJ);

      if(onProgress && (k % step === 0 || k === trials)){
        onProgress(k / trials);
      }
    }

    const total = pw+bw+tw;
    return [pw/total, bw/total, tw/total];
  }

  // =========================
  // EV 建議
  // =========================
  function calcRecommendation(p, b, t){
    // 常見：閒 1:1；莊 1:1 抽 5%；和 8:1
    const evP = p - b;
    const evB = 0.95 * b - p;
    const evT = 8 * t - (1 - t);

    let best = {side:"閒", ev:evP};
    if(evB > best.ev) best = {side:"莊", ev:evB};
    if(evT > best.ev) best = {side:"和", ev:evT};

    if(best.ev < 0) best.side = "不下";
    return best.side;
  }

  function paintRec(side){
    elRec.textContent = side;
    elRec.style.color =
      side==="莊" ? "var(--banker)" :
      side==="閒" ? "var(--player)" :
      side==="和" ? "var(--tie)" : "var(--fg)";
  }

  function pct4(x){ return (x*100).toFixed(4) + "%"; }

  // =========================
  // 狀態
  // =========================
  let shoe = newShoeCounts(N_DECKS);
  let buffer = [];          // 本輪要扣的牌
  let burned = 0;           // 本靴已燒牌張數
  let burnedDone = false;   // 是否已執行燒牌

  // =========================
  // 燒牌（開局一次）
  // =========================
  function burnOnceIfNeeded(){
    if(burnedDone) return;

    // 抽第一張決定燒幾張：先燒第一張 + 再燒 value 張
    const first = drawOneFromCounts(shoe);
    const v = Math.max(1, Math.min(10, (first==="A"?1:(first==="J"||first==="Q"||first==="K"||first==="10")?10:Number(first))));
    const burnN = 1 + v;

    burned = 1; // first already burned
    for(let i=0;i<v;i++){
      if(shoeSize(shoe) <= 0) break;
      drawOneFromCounts(shoe);
      burned++;
    }
    burnedDone = true;
    setMsg(`已燒牌：翻到 ${first} → 燒 ${burnN} 張`, "ok");
  }

  // =========================
  // UI render
  // =========================
  function render(){
    elBuffer.textContent = buffer.length ? buffer.join(" ") : "（尚未輸入）";
    elShoeInfo.textContent = `${N_DECKS}副牌｜剩餘：${shoeSize(shoe)}`;
    elBurnInfo.textContent = burnedDone ? `燒牌：${burned} 張` : `燒牌：未執行`;
  }

  // =========================
  // 保存/載入
  // =========================
  function saveState(){
    try{
      const obj = {
        shoe: Array.from(shoe),
        buffer: buffer.slice(),
        trials: Number(elTrials.value) || 200000,
        burned, burnedDone,
        rec: elRec.textContent,
        p: elP.textContent, b: elB.textContent, t: elT.textContent,
        detailsShown: !elDetails.classList.contains("hide"),
      };
      localStorage.setItem(SAVE_KEY, JSON.stringify(obj));
    }catch(_e){}
  }

  function loadState(){
    try{
      const raw = localStorage.getItem(SAVE_KEY);
      if(!raw) return false;
      const obj = JSON.parse(raw);
      if(!obj || !Array.isArray(obj.shoe) || obj.shoe.length !== RANKS.length) return false;

      shoe = new Int16Array(obj.shoe.map(Number));
      buffer = Array.isArray(obj.buffer) ? obj.buffer.map(String) : [];
      if(obj.trials) elTrials.value = String(obj.trials);

      burned = Number(obj.burned || 0);
      burnedDone = Boolean(obj.burnedDone);

      if(obj.rec) paintRec(obj.rec);
      if(obj.p) elP.textContent = obj.p;
      if(obj.b) elB.textContent = obj.b;
      if(obj.t) elT.textContent = obj.t;

      if(obj.detailsShown) elDetails.classList.remove("hide");
      return true;
    }catch(_e){
      return false;
    }
  }

  // =========================
  // 操作行為
  // =========================
  function addRank(r){
    buffer.push(r);
    render();
    saveState();
  }

  function undoOne(){
    if(buffer.length === 0){
      setMsg("本輪沒有可復原的牌。", "warn");
      return;
    }
    const x = buffer.pop();
    setMsg(`已復原 1 張：${x}`, "ok");
    render();
    saveState();
  }

  function clearBuffer(){
    buffer = [];
    setMsg("已清空本輪輸入。", "ok");
    render();
    saveState();
  }

  function resetAll(){
    shoe = newShoeCounts(N_DECKS);
    buffer = [];
    burned = 0;
    burnedDone = false;
    paintRec("—");
    elP.textContent = elB.textContent = elT.textContent = "—";
    resetProgress();
    setMsg("已重置為新牌靴。", "ok");
    render();
    saveState();
  }

  function computeNext(){
    try{
      resetProgress();
      const trials = Number(elTrials.value);
      if(!Number.isFinite(trials) || trials < 10000){
        setMsg("模擬次數建議 >= 10000。", "warn");
        return;
      }

      // 開局燒牌（只執行一次）
      burnOnceIfNeeded();

      // 扣牌
      if(buffer.length){
        removeCardsFromShoe(shoe, buffer);
      }
      buffer = [];
      render();
      saveState();

      const remain = shoeSize(shoe);
      if(remain < 6){
        setMsg("剩餘牌不足（<6）無法模擬。", "warn");
        return;
      }

      setMsg("計算中…", "muted");

      setTimeout(() => {
        try{
          const [p,b,t] = estimateProbs(shoe, trials, frac => setProgress(frac));

          // 雖然你要「只顯示下注」，但這三個留在細節區（預設隱藏）
          elP.textContent = pct4(p);
          elB.textContent = pct4(b);
          elT.textContent = pct4(t);

          const rec = calcRecommendation(p,b,t);
          paintRec(rec);
          setMsg(`完成（${trials.toLocaleString()} 次）`, "ok");
          render();
          saveState();
        }catch(e){
          setMsg(e.message || String(e), "warn");
          saveState();
        }
      }, 30);

    }catch(e){
      setMsg(e.message || String(e), "warn");
    }
  }

  // =========================
  // 建立按鍵盤
  // =========================
  const pad = document.getElementById("rankPad");
  const padRanks = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  for(const r of padRanks){
    const btn = document.createElement("button");
    btn.className = "rankBtn";
    btn.textContent = r;
    btn.addEventListener("click", () => addRank(r));
    pad.appendChild(btn);
  }

  // =========================
  // 綁定事件
  // =========================
  document.getElementById("btnCompute").addEventListener("click", computeNext);
  document.getElementById("btnUndo").addEventListener("click", undoOne);
  document.getElementById("btnClear").addEventListener("click", clearBuffer);
  document.getElementById("btnReset").addEventListener("click", resetAll);
  document.getElementById("btnToggleDetails").addEventListener("click", () => {
    elDetails.classList.toggle("hide");
    saveState();
  });

  // 快捷鍵（可不用）
  window.addEventListener("keydown", (e) => {
    if(e.key === "Escape") clearBuffer();
    else if(e.key.toUpperCase() === "M") computeNext();
    else if(e.key.toUpperCase() === "R") resetAll();
    else if(e.key === "Backspace") undoOne();
  });

  // 初始
  const loaded = loadState();
  if(!loaded){
    paintRec("—");
    setMsg("準備就緒：按牌面按鈕輸入 → 計算下一局", "ok");
  }else{
    setMsg("已載入上次狀態。", "ok");
  }
  render();
})();
</script>
</body>
</html>