<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>百家樂 PRO｜按鈕輸入扣牌｜8副牌蒙地卡羅</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#ffffff12;
      --line:#ffffff22;
      --P:#1976d2;
      --B:#d32f2f;
      --T:#2e7d32;
      --text:#eaf0ff;
      --muted:#b7c3e6;
      --radius:18px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", Arial, sans-serif;
      background: radial-gradient(1200px 600px at 50% -20%, #2b3cff55, transparent 60%),
                  radial-gradient(900px 500px at 10% 20%, #00d1ff20, transparent 60%),
                  radial-gradient(900px 500px at 90% 20%, #ff3b3020, transparent 60%),
                  var(--bg);
      color:var(--text);
      padding: 18px 14px 24px;
    }
    .app{max-width:1100px;margin:0 auto;}

    .topbar{
      display:grid; grid-template-columns: 1fr auto 1fr;
      gap:10px; border-radius:28px; overflow:hidden;
      box-shadow:var(--shadow); border:1px solid var(--line);
    }
    .side{display:flex;align-items:center;padding:16px;min-height:76px;}
    .side.player{background:linear-gradient(90deg,#0e5fe0,var(--P));}
    .side.banker{background:linear-gradient(90deg,var(--B),#b71c1c);justify-content:flex-end;}
    .label{display:flex;flex-direction:column;gap:2px;font-weight:1000;letter-spacing:.6px;line-height:1.05;}
    .label .zh{font-size:40px;text-shadow:0 2px 0 rgba(0,0,0,.25);}
    .label .en{font-size:18px;opacity:.95;}

    .score{
      display:flex;align-items:center;justify-content:center;
      padding:10px 12px;background:#0000002b;
      border-left:1px solid #ffffff1c;border-right:1px solid #ffffff1c;
      min-width:180px;
      position:relative;
    }
    .score .digit{display:none;}
    #scoreOnly{
      font-size:56px;font-weight:1100;
      text-shadow:0 3px 0 rgba(0,0,0,.25);
      letter-spacing:2px;
      white-space:nowrap;
    }
    .scoreHint{
      position:absolute; bottom:6px; left:50%;
      transform:translateX(-50%);
      font-size:12px; color:var(--muted); opacity:.85;
      white-space:nowrap;
    }

    .grid2{margin-top:12px;display:grid;grid-template-columns: 520px 1fr;gap:12px;}
    @media (max-width: 980px){ .grid2{grid-template-columns:1fr;} .score{min-width:160px;} }

    .panel{
      background: linear-gradient(180deg, #ffffff10, #00000010);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
      min-width:0;
    }
    h1{margin:0 0 8px;font-size:1.25rem;}
    .muted{color:var(--muted);}
    .hr{height:1px;background:#ffffff14;margin:10px 0;}

    .pad{display:grid;grid-template-columns: repeat(7, 1fr);gap:8px;margin-top:10px;}
    .btn{
      appearance:none;border:none;
      background:#ffffff14;border:1px solid #ffffff20;color:var(--text);
      padding:10px 8px;border-radius:14px;
      font-weight:1000;cursor:pointer;user-select:none;
    }
    .btn:hover{background:#ffffff1a;}
    .btn:active{transform:scale(.99);}
    .btn.danger{background:#ff3b3050;border-color:#ff3b3077;}
    .btn.ok{background:#2e7d3250;border-color:#2e7d3277;}
    .btn.small{padding:8px 10px;font-size:13px;font-weight:900;}

    .pills{margin-top:8px; display:flex; flex-wrap:wrap; max-width:100%; gap:6px; overflow:hidden;}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;background:#0000001a;border:1px solid #ffffff20;
      border-radius:999px;font-weight:1000;margin:0;
      max-width:100%;
      flex:0 1 auto;
    }
    .pill .x{opacity:.85;cursor:pointer;border:1px solid #ffffff22;border-radius:999px;padding:0 8px;}

    .probRow{display:grid;grid-template-columns: 1fr 1fr 1fr;gap:10px;margin-top:10px;}
    .prob{
      border:1px solid #ffffff20;background:#0000001a;border-radius:16px;
      padding:10px;min-height:110px;display:flex;flex-direction:column;justify-content:space-between;
      min-width:0;
    }
    .prob .k{font-weight:1100;letter-spacing:.5px;}
    .prob .v{font-size:30px;font-weight:1100;}
    .prob.P .k,.prob.P .v{color:#9ac8ff;}
    .prob.B .k,.prob.B .v{color:#ffb2b2;}
    .prob.T .k,.prob.T .v{color:#aef2c9;}

    .ev{
      margin-top:10px;border:1px solid #ffffff20;background:#0000001a;border-radius:16px;padding:10px;
    }
    .rowline{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
    .rowline > *{min-width:0;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; overflow-wrap:anywhere; word-break:break-word;}
    select,input[type="number"]{
      background:#0000002a;border:1px solid #ffffff20;color:var(--text);
      border-radius:12px;padding:10px 10px;font-weight:900;outline:none;
    }
    .hint{color:var(--muted);font-size:13px;line-height:1.35;opacity:.9;margin-top:8px;}

    html, body { width:100%; max-width:100%; overflow-x:hidden; }
    .grid2 { min-width:0; }

    @media (max-width: 480px){
      .pad { grid-template-columns: repeat(4, 1fr); }
      #btnCalc { grid-column: span 4; }
    }

    .miniRow{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-start;}
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid #ffffff20; background:#00000022;
      font-weight:900;
    }
    .rangeWrap{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    input[type="range"]{ width: 160px; }

    .quickRec{
      position: sticky;
      top: 8px;
      z-index: 80;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
      padding:10px;
      margin:10px 0 6px;
      border:1px solid #ffffff20;
      background:#00000035;
      border-radius:16px;
      backdrop-filter: blur(8px);
    }

    /* ✅ 亂數區段提醒 */
    .warnBox{
      margin-top:10px;
      border:1px solid #ffffff20;
      background:#0000002b;
      border-radius:14px;
      padding:10px;
      display:none;
    }
    .warnBox.show{display:block;}
  </style>
</head>

<body>
<div class="app">

  <div class="topbar">
    <div class="side player">
      <div class="label"><div class="zh">閒</div><div class="en">PLAYER</div></div>
    </div>

    <div class="score" aria-label="Pick">
      <div id="scoreP" class="digit">—</div>
      <div id="scoreB" class="digit">—</div>
      <div id="scoreOnly">—</div>
      <div class="scoreHint">下一把推薦</div>
    </div>

    <div class="side banker">
      <div class="label"><div class="zh">莊</div><div class="en">BANKER</div></div>
    </div>
  </div>

  <div class="quickRec" aria-label="快速記錄上局">
    <button class="btn small" id="recB_top">莊</button>
    <button class="btn small" id="recP_top">閒</button>
    <button class="btn small" id="recT_top">和</button>
    <button class="btn small danger" id="recClear_top">清空</button>
  </div>

  <div class="grid2">

    <div class="panel">
      <h1>① 按鈕輸入已開過的牌（扣牌）</h1>
      <div class="muted">只需要輸入牌點即可（花色不影響百家樂點數/補牌規則）。10/J/Q/K 都算 0 點。</div>

      <div class="hr"></div>

      <div class="rowline">
        <div>
          <div class="muted">鞋狀態</div>
          <div id="shoeInfo" class="mono">—</div>
        </div>
        <div class="rowline" style="gap:8px;">
          <button class="btn danger" id="btnNewShoe">新鞋（重置）</button>
          <button class="btn" id="btnUndo">Undo</button>
          <button class="btn" id="btnClear">清空已輸入</button>
        </div>
      </div>

      <div class="pad" aria-label="Card input">
        <button class="btn" data-r="A">A</button>
        <button class="btn" data-r="2">2</button>
        <button class="btn" data-r="3">3</button>
        <button class="btn" data-r="4">4</button>
        <button class="btn" data-r="5">5</button>
        <button class="btn" data-r="6">6</button>
        <button class="btn" data-r="7">7</button>
        <button class="btn" data-r="8">8</button>
        <button class="btn" data-r="9">9</button>
        <button class="btn" data-r="10">10</button>
        <button class="btn" data-r="J">J</button>
        <button class="btn" data-r="Q">Q</button>
        <button class="btn" data-r="K">K</button>

        <button class="btn ok" id="btnCalc">計算下一局機率</button>
      </div>

      <div class="pills" id="pills"></div>

      <div class="hr"></div>

      <div class="rowline">
        <div>
          <div class="muted">蒙地卡羅次數</div>
          <div class="rowline" style="justify-content:flex-start;">
            <input id="trials" type="number" min="5000" step="5000" value="50000">
            <span class="muted">（手機建議 20,000~80,000）</span>
          </div>
        </div>
      </div>

      <div class="hint">
        提醒：扣牌越多，機率會跟「理論常態」略微偏移；但通常偏移很小。<br>
        下面「實戰派牌路修正」是經驗權重：你可以調小、調大、或關閉。
      </div>
    </div>

    <div class="panel">
      <h1>③ 下一局：莊 / 閒 / 和 機率（8副牌｜扣牌後｜MC）</h1>

      <div class="probRow">
        <div class="prob B">
          <div class="k">莊 勝率</div>
          <div class="v" id="pB">—</div>
          <div class="muted mono" id="pB2">—</div>
          <div class="muted mono" id="pB_adj">修正後：—</div>
        </div>
        <div class="prob P">
          <div class="k">閒 勝率</div>
          <div class="v" id="pP">—</div>
          <div class="muted mono" id="pP2">—</div>
          <div class="muted mono" id="pP_adj">修正後：—</div>
        </div>
        <div class="prob T">
          <div class="k">和 勝率</div>
          <div class="v" id="pT">—</div>
          <div class="muted mono" id="pT2">—</div>
          <div class="muted mono" id="pT_adj">修正後：—</div>
        </div>
      </div>

      <div class="ev">
        <div class="rowline">
          <div style="font-weight:1100;">策略（實戰）</div>
          <div class="rowline" style="gap:8px;">
            <span class="muted">莊抽水</span>
            <select id="commission">
              <option value="0.05" selected>5%（常見）</option>
              <option value="0.00">0%（免水）</option>
            </select>
          </div>
        </div>

        <div class="hr"></div>

        <div class="rowline" style="gap:8px;">
          <span class="muted">策略</span>
          <select id="strategy">
            <option value="evmax" selected>EV 最大（永遠下注）</option>
            <option value="negok">容忍負EV也下注</option>
            <option value="follow">追路（連莊/連閒就跟）</option>
            <option value="fade">反向（連莊/連閒就反買）</option>
            <option value="martingale">馬丁倍壓（輸就倍壓，上限封頂）</option>
          </select>

          <span class="muted">負EV容忍</span>
          <input id="negTol" type="number" step="0.001" value="-0.010" style="width:110px;">
        </div>

        <div class="rowline" style="gap:8px;margin-top:8px;">
          <span class="muted">追路/反向 需要連續</span>
          <input id="streakN" type="number" min="2" step="1" value="2" style="width:80px;">
          <span class="muted">次</span>

          <span class="muted">馬丁上限</span>
          <input id="martCap" type="number" min="2" step="1" value="8" style="width:80px;">
          <span class="muted">單位</span>
        </div>

        <div class="hr"></div>

        <!-- ✅ 1) EV 門檻 PASS 模式 -->
        <div class="rowline">
          <div style="font-weight:1100;">EV 門檻 PASS 模式</div>
          <div class="miniRow">
            <label class="chip">
              <input id="passOn" type="checkbox" checked>
              啟用 PASS
            </label>
            <label class="chip">
              門檻 <input id="passEV" type="number" step="0.001" value="0.002" style="width:90px;">
              <span class="muted">（例 0.002）</span>
            </label>
          </div>
        </div>

        <div class="hr"></div>

        <div class="rowline">
          <div style="font-weight:1100;">實戰派：牌路修正（可調）</div>
          <div class="miniRow">
            <label class="chip">
              <input id="roadOn" type="checkbox" checked>
              啟用修正
            </label>
            <label class="chip">
              最近 <input id="roadWin" type="number" min="6" max="60" step="2" value="18" style="width:80px;">
              手
            </label>
          </div>
        </div>

        <div class="hr"></div>

        <div class="miniRow">
          <div class="rangeWrap">
            <span class="muted">連莊/連閒（順勢）</span>
            <input id="wTrend" type="range" min="0" max="30" value="10">
            <span class="mono" id="wTrendV">0.010</span>
          </div>
          <div class="rangeWrap">
            <span class="muted">斬龍/跳（逆勢）</span>
            <input id="wChop" type="range" min="0" max="30" value="8">
            <span class="mono" id="wChopV">0.008</span>
          </div>
          <div class="rangeWrap">
            <span class="muted">和局偏高</span>
            <input id="wTie" type="range" min="0" max="30" value="6">
            <span class="mono" id="wTieV">0.006</span>
          </div>
        </div>

        <div class="hr"></div>

        <div class="mono" id="evLine">—</div>

        <!-- ✅ 只顯示：莊/閒/和；若 PASS → 顯示 PASS -->
        <div class="mono" id="betLine" style="margin-top:6px;font-size:34px;font-weight:1100;letter-spacing:2px;">—</div>

        <!-- ✅ 2) 亂數區段提醒 -->
        <div class="warnBox" id="noiseBox">
          <div style="font-weight:1100;">⚠️ 偵測到可能「亂數區段」</div>
          <div class="muted" id="noiseWarn" style="margin-top:6px;">—</div>
        </div>

        <div class="hint">上面固定的「莊/閒/和」用來記錄上局結果（影響牌路/追路/倍壓/回測）。</div>
      </div>

      <div class="hr"></div>

      <div class="rowline" style="justify-content:space-between; gap:10px;">
        <div>
          <div class="muted">上局勝家</div>
          <div class="mono" id="lastWinner">—</div>
          <div class="muted mono" id="lastStreak">—</div>
        </div>
        <div style="text-align:right;">
          <div class="muted">近 N 把命中率回測（只算有下注）</div>
          <div class="rowline" style="gap:8px; justify-content:flex-end;">
            <span class="muted">N</span>
            <input id="backN" type="number" min="5" step="5" value="30" style="width:90px;">
          </div>
          <div class="mono" id="backLine" style="margin-top:6px;">—</div>
        </div>
      </div>

      <div class="hr"></div>
      <div class="muted">最後一次計算耗時：<span class="mono" id="ms">—</span></div>
    </div>

  </div>
</div>

<script>
/* ===========================
   狀態
=========================== */
const betState = {
  history: [],         // 'B'|'P'|'T'（上局結果）
  lastPick: null,      // 真正下注方向：'B'|'P'；PASS 時為 null
  unit: 1,
  logs: []             // 回測：每把 {pick,result,unit,ts}
};
let lastCalc = { has:false, pP:0,pB:0,pT:0, aP:0,aB:0,aT:0 };

/* ===========================
   工具
=========================== */
function setText(id, txt){
  const el = document.getElementById(id);
  if (el) el.textContent = txt;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function fmtPct(x){ return (x*100).toFixed(3) + '%'; }
function sideName(s){ return s==='B' ? '莊' : s==='P' ? '閒' : s==='T' ? '和' : '—'; }
function opposite(side){ return side === 'B' ? 'P' : side === 'P' ? 'B' : 'T'; }

function lastNonTieStreak(hist){
  let i = hist.length - 1;
  while (i >= 0 && hist[i] === 'T') i--;
  if (i < 0) return {side:null, len:0};
  const side = hist[i];
  let len = 0;
  while (i >= 0){
    if (hist[i] === 'T') { i--; continue; }
    if (hist[i] !== side) break;
    len++; i--;
  }
  return {side, len};
}

function calcEV(pP, pB, pT, commission){
  const evP = 2*pP - 1;
  const evB = pB*(1-commission) - (1-pB);
  const evT = 9*pT - 1;
  return {evP, evB, evT};
}

/* ===========================
   1) EV 門檻 PASS 模式
=========================== */
function getPassParams(){
  const on = !!document.getElementById('passOn')?.checked;
  const passEV = parseFloat(document.getElementById('passEV')?.value || '0.002');
  return { on, passEV };
}

/* ===========================
   實戰派：牌路修正
=========================== */
function getRoadParams(){
  const on = !!document.getElementById('roadOn')?.checked;
  const win = Math.max(6, Math.min(60, parseInt(document.getElementById('roadWin')?.value,10) || 18));
  const wTrend = (parseInt(document.getElementById('wTrend')?.value,10) || 0) / 1000;
  const wChop  = (parseInt(document.getElementById('wChop')?.value,10) || 0) / 1000;
  const wTie   = (parseInt(document.getElementById('wTie')?.value,10) || 0) / 1000;
  return {on, win, wTrend, wChop, wTie};
}
function updateRoadParamLabels(){
  const p = getRoadParams();
  setText('wTrendV', p.wTrend.toFixed(3));
  setText('wChopV',  p.wChop.toFixed(3));
  setText('wTieV',   p.wTie.toFixed(3));
}

function roadFeatures(hist, win){
  const recent = hist.slice(-win);
  const nonTie = recent.filter(x=>x!=='T');
  const last = nonTie.length ? nonTie[nonTie.length-1] : null;

  let streakSide = null, streakLen = 0;
  if (nonTie.length){
    streakSide = nonTie[nonTie.length-1];
    for (let i=nonTie.length-1;i>=0;i--){
      if (nonTie[i] === streakSide) streakLen++;
      else break;
    }
  }

  let switches=0, pairs=0;
  for (let i=1;i<nonTie.length;i++){
    pairs++;
    if (nonTie[i] !== nonTie[i-1]) switches++;
  }
  const chopRate = pairs ? switches/pairs : 0;
  const tieRate = recent.length ? recent.filter(x=>x==='T').length / recent.length : 0;

  return {recent, nonTie, last, streakSide, streakLen, chopRate, tieRate};
}

function applyRoadAdjust(pP, pB, pT, hist){
  const p = getRoadParams();
  if (!p.on) return {pP, pB, pT, note:'修正關閉'};

  const f = roadFeatures(hist, p.win);
  const baseTie = 0.095;

  let dB = 0, dP = 0, dT = 0;
  let notes = [];

  if (f.streakSide && f.streakLen >= 2){
    const k = clamp((f.streakLen - 1) / 6, 0, 1);
    const push = p.wTrend * k;
    if (f.streakSide === 'B'){ dB += push; dP -= push; notes.push(`順勢+${push.toFixed(3)}`); }
    if (f.streakSide === 'P'){ dP += push; dB -= push; notes.push(`順勢+${push.toFixed(3)}`); }
  }

  if (f.last && f.nonTie.length >= 6){
    const k = clamp((f.chopRate - 0.55) / 0.35, 0, 1);
    const push = p.wChop * k;
    if (push > 0){
      const opp = opposite(f.last);
      if (opp === 'B'){ dB += push; dP -= push; notes.push(`跳路+${push.toFixed(3)}`); }
      if (opp === 'P'){ dP += push; dB -= push; notes.push(`跳路+${push.toFixed(3)}`); }
    }
  }

  if (f.recent.length >= 10){
    const k = clamp((f.tieRate - baseTie) / 0.08, 0, 1);
    const push = p.wTie * k;
    if (push > 0){
      dT += push; dB -= push/2; dP -= push/2;
      notes.push(`和偏高+${push.toFixed(3)}`);
    }
  }

  let aB = clamp(pB + dB, 0.001, 0.999);
  let aP = clamp(pP + dP, 0.001, 0.999);
  let aT = clamp(pT + dT, 0.001, 0.999);
  const s = aB + aP + aT;
  aB/=s; aP/=s; aT/=s;

  return {pP:aP, pB:aB, pT:aT, note: notes.length ? notes.join('｜') : '無顯著牌路訊號'};
}

/* ===========================
   推薦邏輯（含 PASS）
=========================== */
function pickByStrategy(pP, pB, pT){
  const commission = parseFloat(document.getElementById('commission')?.value || '0.05');
  const strategy = document.getElementById('strategy')?.value || 'evmax';
  const streakN = Math.max(2, parseInt(document.getElementById('streakN')?.value,10) || 2);

  const {evP, evB, evT} = calcEV(pP, pB, pT, commission);

  // 先照 EV 排（含和）
  const evList = [
    {side:'P', ev:evP},
    {side:'B', ev:evB},
    {side:'T', ev:evT},
  ].sort((a,b)=>b.ev-a.ev);

  const best = evList[0];
  const streak = lastNonTieStreak(betState.history);

  let pick = best.side;

  if (strategy === 'follow'){
    if (streak.side && streak.len >= streakN) pick = streak.side;
  } else if (strategy === 'fade'){
    if (streak.side && streak.len >= streakN) pick = opposite(streak.side);
  }

  // ✅ 和最高時：仍給一個下注方向（莊/閒取 EV 較高）
  const bpPick = (evB >= evP) ? 'B' : 'P';

  return { pick, bpPick, evP, evB, evT };
}

function updateBetUI(pP, pB, pT){
  const out = pickByStrategy(pP, pB, pT);

  // ✅ PASS 規則：只看「莊/閒」的 maxEV（因為你實戰主要下注 B/P）
  const { on, passEV } = getPassParams();
  const maxBP = Math.max(out.evB, out.evP);
  const doPass = on && (maxBP < passEV);

  // 顯示文字
  let show = '';
  if (doPass){
    show = 'PASS';
    betState.lastPick = null; // ✅ 不下注
  } else {
    show = (out.pick === 'T') ? `和/${sideName(out.bpPick)}` : sideName(out.pick);
    betState.lastPick = (out.pick === 'T') ? out.bpPick : out.pick; // ✅ 真正下注方向只會是 B/P
  }

  // 顯示 EV line（也把 PASS 條件顯示出來，方便看）
  setText('evLine',
    `EV(閒)=${out.evP.toFixed(5)}｜EV(莊)=${out.evB.toFixed(5)}｜EV(和)=${out.evT.toFixed(5)}｜` +
    `PASS門檻=${passEV}｜目前max(B/P)=${maxBP.toFixed(5)}`
  );

  setText('betLine', show);
  setText('scoreOnly', show);
}

/* ===========================
   上局勝家
=========================== */
function updateLastWinnerUI(){
  if (!betState.history.length){
    setText('lastWinner', '—');
    setText('lastStreak', '—');
    return;
  }
  const last = betState.history[betState.history.length - 1];
  setText('lastWinner', `上局：${sideName(last)}`);

  const streak = lastNonTieStreak(betState.history);
  if (streak.side) setText('lastStreak', `目前：${sideName(streak.side)} 連 ${streak.len}`);
  else setText('lastStreak', `目前：—`);
}

/* ===========================
   3) 回測：只算有下注的把數
   - N 是「近 N 把下注」
   - PASS 不算
=========================== */
function calcBacktest(N){
  const logs = betState.logs || [];
  const betLogs = logs.filter(x => x && (x.pick === 'B' || x.pick === 'P')); // ✅ 只算有下注

  if (!betLogs.length){
    setText('backLine', '—（目前沒有下注紀錄）');
    return;
  }

  const n = Math.max(5, Math.min(500, parseInt(N,10) || 30));
  const last = betLogs.slice(-n); // ✅ 近 N 把「下注」

  let win=0, loss=0, push=0;
  let netUnits = 0;

  for (const x of last){
    if (x.result === 'T'){
      push++; // ✅ 有下注但開和：push
      continue;
    }
    if (x.result === x.pick){
      win++; netUnits += (x.unit || 1);
    } else {
      loss++; netUnits -= (x.unit || 1);
    }
  }

  const denom = win + loss; // ✅ 命中率只用「決勝負」的把數
  const hit = denom ? (win/denom) : 0;

  setText('backLine',
    `回測近 ${last.length} 把(下注)：命中 ${win}｜失誤 ${loss}｜Push(和) ${push}｜` +
    `命中率 ${(hit*100).toFixed(2)}%｜淨單位 ${netUnits>0?'+':''}${netUnits}`
  );

  // ✅ 2) 同步偵測亂數區段
  detectNoiseSegment(last);
}

/* ===========================
   2) 偵測「亂數區段」提醒停手
   規則（只看近 M 把下注）：
   - M >= 20 才判斷
   - 命中率接近 50%（45%~55%）
   - 淨單位接近 0（|net| <= 2）
   - 結果跳路率高（非和結果 B/P 交替率高）
=========================== */
function detectNoiseSegment(lastBetLogs){
  const box = document.getElementById('noiseBox');
  const warn = document.getElementById('noiseWarn');
  if (!box || !warn) return;

  const M = lastBetLogs.length;
  if (M < 20){
    box.classList.remove('show');
    return;
  }

  let win=0, loss=0, push=0, net=0;
  const results = []; // 用來算跳路（只看 B/P 結果）
  for (const x of lastBetLogs){
    if (x.result === 'T'){ push++; continue; }
    results.push(x.result);
    if (x.result === x.pick){ win++; net += (x.unit||1); }
    else { loss++; net -= (x.unit||1); }
  }

  const denom = win + loss;
  const hit = denom ? win/denom : 0;

  // 跳路率
  let switches=0, pairs=0;
  for (let i=1;i<results.length;i++){
    pairs++;
    if (results[i] !== results[i-1]) switches++;
  }
  const chopRate = pairs ? switches/pairs : 0;

  const near50 = (hit >= 0.45 && hit <= 0.55);
  const near0  = (Math.abs(net) <= 2);
  const choppy = (chopRate >= 0.60);

  if (near50 && near0 && choppy){
    box.classList.add('show');
    warn.textContent =
      `近 ${M} 把(下注)：命中率 ${(hit*100).toFixed(1)}%｜淨單位 ${net>0?'+':''}${net}｜跳路率 ${(chopRate*100).toFixed(0)}% → 建議「停手/縮小單位/等訊號」`;
  } else {
    box.classList.remove('show');
  }
}

/* ===========================
   記錄上局結果（莊/閒/和）
   - 如果 PASS：不寫入下注 log（或 pick=null），回測只算下注所以不影響
=========================== */
function recordResult(r){
  // ① 記錄上局結果（牌路）
  betState.history.push(r);
  updateLastWinnerUI();

  // ② 馬丁：只在「有下注」時才影響（PASS 不動）
  const martCap = Math.max(2, parseInt(document.getElementById('martCap')?.value,10) || 8);
  const strategy = document.getElementById('strategy')?.value || 'evmax';

  const usedUnit = betState.unit || 1;
  const hasBet = (betState.lastPick === 'B' || betState.lastPick === 'P');

  if (hasBet && strategy === 'martingale'){
    if (r === 'T'){
      // push 不變
    } else if (r === betState.lastPick){
      betState.unit = 1;
    } else {
      betState.unit = Math.min(betState.unit * 2, martCap);
    }
  }

  // ③ 寫入 log（PASS 也記錄，但 pick=null；回測會自動忽略）
  betState.logs.push({
    pick: hasBet ? betState.lastPick : null,
    result: r,
    unit: hasBet ? usedUnit : 0,
    ts: Date.now()
  });

  // ④ 若已算過 → 不重跑 MC，直接用同一套「原始機率 + 新牌路」更新
  if (lastCalc.has){
    const adj = applyRoadAdjust(lastCalc.pP, lastCalc.pB, lastCalc.pT, betState.history);
    lastCalc.aP = adj.pP; lastCalc.aB = adj.pB; lastCalc.aT = adj.pT;
    updateBetUI(adj.pP, adj.pB, adj.pT);
  }

  // ⑤ 更新回測（只算下注）
  const N = document.getElementById('backN')?.value || 30;
  calcBacktest(N);
}

/* ===========================
   扣牌 & MC
=========================== */
const DECKS = 8;
const counts0 = () => {
  const c = new Array(10).fill(0);
  c[0] = 16 * DECKS;
  for (let v=1; v<=9; v++) c[v] = 4 * DECKS;
  return c;
};

const state = { shoe: counts0(), seen: [], inited: false };

const rankToValue = (r) => {
  if (r === 'A') return 1;
  if (r === 'J' || r === 'Q' || r === 'K' || r === '10') return 0;
  const n = parseInt(r,10);
  if (!Number.isFinite(n) || n<2 || n>9) return null;
  return n;
};

function sumCounts(c){ return c.reduce((a,b)=>a+b,0); }
function shoeInfoText(){
  const left = sumCounts(state.shoe);
  const used = 416 - left;
  return `總張數 416｜已扣 ${used}｜剩餘 ${left}`;
}

function drawCard(counts){
  const total = sumCounts(counts);
  if (total <= 0) return null;
  let r = Math.floor(Math.random() * total);
  for (let v=0; v<=9; v++){
    const k = counts[v];
    if (r < k){ counts[v]--; return v; }
    r -= k;
  }
  return null;
}
function mod10(x){ return ((x%10)+10)%10; }

function resolveHand(counts){
  const p1 = drawCard(counts), b1 = drawCard(counts);
  const p2 = drawCard(counts), b2 = drawCard(counts);
  if (p1===null||b1===null||p2===null||b2===null) return null;

  let pTotal = mod10(p1+p2);
  let bTotal = mod10(b1+b2);

  if (pTotal>=8 || bTotal>=8){
    if (pTotal>bTotal) return 'P';
    if (bTotal>pTotal) return 'B';
    return 'T';
  }

  let p3 = null;
  if (pTotal <= 5){
    p3 = drawCard(counts);
    if (p3===null) return null;
    pTotal = mod10(pTotal + p3);
  }

  let b3 = null;
  if (p3 === null){
    if (bTotal <= 5){
      b3 = drawCard(counts);
      if (b3===null) return null;
      bTotal = mod10(bTotal + b3);
    }
  } else {
    const pt = p3;
    if (bTotal <= 2) b3 = drawCard(counts);
    else if (bTotal === 3){ if (pt !== 8) b3 = drawCard(counts); }
    else if (bTotal === 4){ if (pt >= 2 && pt <= 7) b3 = drawCard(counts); }
    else if (bTotal === 5){ if (pt >= 4 && pt <= 7) b3 = drawCard(counts); }
    else if (bTotal === 6){ if (pt === 6 || pt === 7) b3 = drawCard(counts); }
    if (b3 !== null) bTotal = mod10(bTotal + b3);
  }

  if (pTotal>bTotal) return 'P';
  if (bTotal>pTotal) return 'B';
  return 'T';
}

function initNewShoe(){
  state.shoe = counts0();
  state.seen = [];
  state.inited = true;
  renderAll();
}
function canRemoveValue(v){ return v!==null && v>=0 && v<=9 && state.shoe[v] > 0; }

function addSeenRank(r){
  const v = rankToValue(r);
  if (v === null) return;
  if (!canRemoveValue(v)){ alert('該點數牌已被扣光（或鞋已空），不能再輸入。'); return; }
  state.shoe[v]--;
  state.seen.push(v);
  renderAll();
}
function undo(){
  if (state.seen.length===0) return;
  const v = state.seen.pop();
  state.shoe[v]++;
  renderAll();
}
function clearSeen(){
  for (const v of state.seen) state.shoe[v]++;
  state.seen = [];
  renderAll();
}
function clearSeenUIOnly(){ state.seen = []; renderAll(); }

function renderPills(){
  const el = document.getElementById('pills');
  if (!el) return;
  el.innerHTML = '';
  const toRank = (v) => v===0 ? '10/J/Q/K' : (v===1 ? 'A' : String(v));
  state.seen.forEach((v, idx) => {
    const pill = document.createElement('span');
    pill.className = 'pill';
    pill.innerHTML = `<span class="mono">#${idx+1}</span> <span>${toRank(v)}</span> <span class="x" title="移除">×</span>`;
    pill.querySelector('.x').addEventListener('click', () => {
      state.shoe[v]++;
      state.seen.splice(idx,1);
      renderAll();
    });
    el.appendChild(pill);
  });
}
function renderAll(){
  setText('shoeInfo', shoeInfoText());
  renderPills();
}

async function runMC(){
  if (!state.inited) initNewShoe();
  updateRoadParamLabels();

  const trials = Math.max(5000, Math.min(500000, parseInt(document.getElementById('trials')?.value,10) || 50000));
  document.getElementById('trials').value = trials;

  if (sumCounts(state.shoe) < 60){
    alert('剩餘牌太少，建議開新鞋。');
    return;
  }

  const t0 = performance.now();
  let wP=0, wB=0, wT=0, bad=0;

  for (let i=0;i<trials;i++){
    const c = state.shoe.slice();
    const r = resolveHand(c);
    if (!r){ bad++; continue; }
    if (r==='P') wP++;
    else if (r==='B') wB++;
    else wT++;
  }

  const n = wP+wB+wT;
  const pP = n ? (wP/n) : 0;
  const pB = n ? (wB/n) : 0;
  const pT = n ? (wT/n) : 0;
  const t1 = performance.now();

  setText('pP', fmtPct(pP)); setText('pB', fmtPct(pB)); setText('pT', fmtPct(pT));
  setText('pP2', `樣本 ${wP}/${n}`); setText('pB2', `樣本 ${wB}/${n}`); setText('pT2', `樣本 ${wT}/${n}`);
  setText('ms', (t1-t0).toFixed(0) + ' ms');

  const adj = applyRoadAdjust(pP, pB, pT, betState.history);
  setText('pP_adj', `修正後：${fmtPct(adj.pP)}`);
  setText('pB_adj', `修正後：${fmtPct(adj.pB)}`);
  setText('pT_adj', `修正後：${fmtPct(adj.pT)}`);

  lastCalc = { has:true, pP, pB, pT, aP:adj.pP, aB:adj.pB, aT:adj.pT };

  updateBetUI(adj.pP, adj.pB, adj.pT);

  const N = document.getElementById('backN')?.value || 30;
  calcBacktest(N);

  clearSeenUIOnly();
  if (bad>0) console.log('bad trials:', bad);
}

/* ===========================
   綁定事件
=========================== */
function on(id, ev, fn){
  const el = document.getElementById(id);
  if (el) el.addEventListener(ev, fn);
}

window.addEventListener('DOMContentLoaded', () => {
  updateRoadParamLabels();
  setText('scoreOnly','—');

  const pad = document.querySelector('.pad');
  if (pad){
    pad.addEventListener('click', (e) => {
      const btn = e.target.closest('[data-r]');
      if (!btn) return;
      addSeenRank(btn.getAttribute('data-r'));
    });
  }

  on('btnUndo', 'click', undo);
  on('btnClear', 'click', clearSeen);
  on('btnNewShoe', 'click', initNewShoe);
  on('btnCalc', 'click', runMC);

  on('recB_top','click', ()=> recordResult('B'));
  on('recP_top','click', ()=> recordResult('P'));
  on('recT_top','click', ()=> recordResult('T'));

  on('recClear_top','click', ()=>{
    betState.history = [];
    betState.logs = [];
    betState.unit = 1;
    betState.lastPick = null;
    lastCalc = {has:false,pP:0,pB:0,pT:0,aP:0,aB:0,aT:0};

    setText('betLine','—');
    setText('scoreOnly','—');
    setText('lastWinner','—');
    setText('lastStreak','—');
    setText('backLine','—');
    setText('pP_adj','修正後：—');
    setText('pB_adj','修正後：—');
    setText('pT_adj','修正後：—');

    const box = document.getElementById('noiseBox');
    if (box) box.classList.remove('show');
  });

  // 參數改動：只更新顯示值，不自動跑 MC
  ['roadOn','roadWin','wTrend','wChop','wTie','passOn','passEV'].forEach(id=>{
    on(id, 'input', updateRoadParamLabels);
    on(id, 'change', updateRoadParamLabels);
  });

  // N 改變 → 立刻更新回測（只算下注）
  on('backN','input', ()=>{
    const N = document.getElementById('backN')?.value || 30;
    calcBacktest(N);
  });

  initNewShoe();
});
</script>
</body>
</html>